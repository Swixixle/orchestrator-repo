#!/usr/bin/env node
/**
 * Verify CLI – offline verification of a previously produced artifact.
 *
 * Usage:
 *   npm run verify -- --artifact out/artifact.json
 *
 * Exits 0 when all checks pass, 1 when any check fails.
 *
 * Checks performed:
 *   1. HALO receipt verification via halo-receipts contract
 *   2. ELI semantic validation re-run on stored ledger
 *   3. Credential leak scan on transcript + receipt + provenance
 *
 * Writes out/verify_report.md (or --out-dir/verify_report.md).
 */
import { readFileSync, mkdirSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { verifyHaloReceiptAdapter } from "../adapters/haloReceiptsAdapter.js";
import { validateLedgerSemantics } from "../adapters/eliAdapter.js";
import { scanForLeaks } from "../utils/leakScan.js";
import type { Artifact } from "../types/artifact.js";
import { verifyCheckpointOffline } from "./ingestValet.js";

interface CheckpointBundle {
  master_receipt: Record<string, unknown>;
  evidence_pack: Record<string, unknown>;
}

// ── Helpers ───────────────────────────────────────────────────────────────────

function parseArgs(argv: string[]): { artifactPath: string; outDir: string } {
  const args = argv.slice(2);
  let artifactPath: string | undefined;
  let outDir = "out";

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if ((arg === "--artifact" || arg === "-a") && args[i + 1]) {
      artifactPath = args[++i];
    } else if (arg === "--out-dir" && args[i + 1]) {
      outDir = args[++i];
    }
  }

  if (!artifactPath) {
    throw new Error("Provide --artifact <path> (e.g. out/artifact.json).");
  }

  return { artifactPath: resolve(artifactPath), outDir };
}

function loadArtifact(path: string): Artifact {
  let raw: string;
  try {
    raw = readFileSync(path, "utf8");
  } catch (err) {
    throw new Error(`Cannot read artifact file: ${path}\n  ${String(err)}`);
  }
  try {
    return JSON.parse(raw) as Artifact;
  } catch (err) {
    throw new Error(`Artifact is not valid JSON: ${path}\n  ${String(err)}`);
  }
}

function isCheckpointBundle(value: unknown): value is CheckpointBundle {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }

  const root = value as Record<string, unknown>;
  return Boolean(
    root.master_receipt &&
      typeof root.master_receipt === "object" &&
      root.evidence_pack &&
      typeof root.evidence_pack === "object"
  );
}

interface CheckResult {
  name: string;
  passed: boolean;
  detail: string;
}

function buildVerifyReport(
  artifactPath: string,
  checks: CheckResult[],
  overallPassed: boolean
): string {
  const status = overallPassed ? "✅ PASS" : "❌ FAIL";
  const rows = checks
    .map((c) => `| ${c.name} | ${c.passed ? "✅ PASS" : "❌ FAIL"} | ${c.detail} |`)
    .join("\n");

  return `# Offline Verification Report

**Artifact:** \`${artifactPath}\`
**Overall:** ${status}

## Checks

| Check | Result | Detail |
|-------|--------|--------|
${rows}

---
_Generated by \`npm run verify\`_
`;
}

// ── Main ──────────────────────────────────────────────────────────────────────

export async function runVerify(argv: string[]): Promise<boolean> {
  const { artifactPath, outDir } = parseArgs(argv);

  console.log(`[verify] Loading artifact: ${artifactPath}`);
  const artifact = loadArtifact(artifactPath) as unknown;

  if (isCheckpointBundle(artifact)) {
    return runCheckpointVerify(artifactPath, artifact, outDir);
  }

  const orchestratorArtifact = artifact as Artifact;

  const checks: CheckResult[] = [];

  // ── Check 1: HALO receipt verification ──────────────────────────────────

  try {
    const verifyResult = await verifyHaloReceiptAdapter(
      orchestratorArtifact.transcript,
      orchestratorArtifact.haloReceipt
    );
    checks.push({
      name: "HALO receipt verification",
      passed: verifyResult.ok,
      detail: verifyResult.ok
        ? "Transcript hash matches receipt."
        : `Errors: ${(verifyResult.errors ?? []).join("; ")}`,
    });
  } catch (err) {
    checks.push({
      name: "HALO receipt verification",
      passed: false,
      detail: `Exception: ${err instanceof Error ? err.message : String(err)}`,
    });
  }

  // ── Check 2: ELI semantic validation re-run ──────────────────────────────

  try {
    // Re-derive source text from the ledger claims' spans, or use the
    // first claim's text as a proxy. The validator works on the claim
    // span data; re-running it over the stored ledger + reconstructed text.
    const claims = orchestratorArtifact.eliLedger?.claims ?? [];
    // Reconstruct approximate source from claim texts
    const reconstructedSource = claims.map((c) => c.text).join(" ");
    const revalidation = validateLedgerSemantics(orchestratorArtifact.eliLedger, reconstructedSource);
    checks.push({
      name: "ELI semantic validation",
      passed: revalidation.ok,
      detail: revalidation.ok
        ? `${claims.length} claims, no ERROR issues.`
        : `Issues: ${revalidation.issues.map((i) => `[${i.severity}] ${i.rule}`).join("; ")}`,
    });
  } catch (err) {
    checks.push({
      name: "ELI semantic validation",
      passed: false,
      detail: `Exception: ${err instanceof Error ? err.message : String(err)}`,
    });
  }

  // ── Check 3: Credential leak scan ────────────────────────────────────────

  const leakScan = scanForLeaks(
    [
      { field: "transcript", value: orchestratorArtifact.transcript },
      { field: "haloReceipt", value: orchestratorArtifact.haloReceipt },
      { field: "provenance", value: orchestratorArtifact.provenance },
    ],
    [process.env.OPENAI_API_KEY].filter((k): k is string => typeof k === "string")
  );
  checks.push({
    name: "Credential leak scan",
    passed: leakScan.ok,
    detail: leakScan.ok
      ? "No credential patterns found."
      : `Findings: ${leakScan.findings.map((f) => `${f.location}: ${f.pattern}`).join("; ")}`,
  });

  // ── Output ────────────────────────────────────────────────────────────────

  const overallPassed = checks.every((c) => c.passed);
  const report = buildVerifyReport(artifactPath, checks, overallPassed);

  mkdirSync(resolve(outDir), { recursive: true });
  writeFileSync(resolve(outDir, "verify_report.md"), report, "utf8");

  console.log("\n[verify] Results:");
  for (const c of checks) {
    console.log(`  ${c.passed ? "✅" : "❌"} ${c.name}: ${c.detail}`);
  }
  console.log(`\n[verify] Report written to ${outDir}/verify_report.md`);
  console.log(`[verify] Overall: ${overallPassed ? "✅ PASS" : "❌ FAIL"}`);

  return overallPassed;
}

function runCheckpointVerify(
  artifactPath: string,
  bundle: CheckpointBundle,
  outDir: string
): boolean {
  const checks: CheckResult[] = [];

  const checkpointVerify = verifyCheckpointOffline({
    masterReceipt: bundle.master_receipt as never,
    evidencePack: bundle.evidence_pack as never,
    verifyKeyPem: process.env.RECEIPT_VERIFY_KEY,
  });

  checks.push({
    name: "Checkpoint hash/signature verification",
    passed: checkpointVerify.ok,
    detail: checkpointVerify.ok ? "content_hash + Ed25519 verified." : checkpointVerify.reason ?? "failed",
  });

  const assertions = Array.isArray(bundle.evidence_pack.eli_assertions)
    ? bundle.evidence_pack.eli_assertions
    : [];
  checks.push({
    name: "ELI assertions present",
    passed: assertions.length > 0,
    detail: `assertion count: ${assertions.length}`,
  });

  const leakScan = scanForLeaks(
    [
      { field: "master_receipt", value: bundle.master_receipt },
      { field: "evidence_pack", value: bundle.evidence_pack },
    ],
    [process.env.OPENAI_API_KEY].filter((k): k is string => typeof k === "string")
  );
  checks.push({
    name: "Credential leak scan",
    passed: leakScan.ok,
    detail: leakScan.ok
      ? "No credential patterns found."
      : `Findings: ${leakScan.findings.map((f) => `${f.location}: ${f.pattern}`).join("; ")}`,
  });

  const overallPassed = checks.every((check) => check.passed);
  const report = buildVerifyReport(artifactPath, checks, overallPassed);

  mkdirSync(resolve(outDir), { recursive: true });
  writeFileSync(resolve(outDir, "verify_report.md"), report, "utf8");

  console.log("\n[verify] Results:");
  for (const check of checks) {
    console.log(`  ${check.passed ? "✅" : "❌"} ${check.name}: ${check.detail}`);
  }
  console.log(`\n[verify] Report written to ${outDir}/verify_report.md`);
  console.log(`[verify] Overall: ${overallPassed ? "✅ PASS" : "❌ FAIL"}`);

  return overallPassed;
}

// ── Entry ─────────────────────────────────────────────────────────────────────

if (process.argv[1] && fileURLToPath(import.meta.url) === resolve(process.argv[1])) {
  runVerify(process.argv).then((passed) => {
    process.exit(passed ? 0 : 1);
  }).catch((err: unknown) => {
    console.error("[verify] ERROR:", err instanceof Error ? err.message : err);
    process.exit(1);
  });
}
